#include "keys_ru.h"
#include "keys_ru.h"
#include <behaviors.dtsi>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/outputs.h>

&mt {
    quick-tap-ms = <200>;
    flavor = "tap-preferred";
    require-prior-idle-ms = <125>;
};

/ {
    behaviors {
        /*
 * vf-adapt.h
 *
 * SPDX-License-Identifier: MIT
 *
 * AdaptiveKey behaviors
 * (send a different behavior based on prior key)
 *
 * these are dependant on the underlying alpha layout
 *
 * using urob's behavior-adaptive-key module (https://github.com/urob/zmk-adaptive-key/)
 */
 
        ak_A: ak_A {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp A>;

            akA_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(A)>; strict-modifiers; };
        };
        ak_B: ak_B {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp B>;

            akB_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(B)>; strict-modifiers; };
        };
        ak_C: ak_C {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp C>;

            akC_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(C)>; strict-modifiers; };
            akC_t_ch { trigger-keys = <T>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp C &kp H>; };
        };
        ak_D: ak_D {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp D>;

            akD_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(D)>; strict-modifiers; };
            akD_t_l { trigger-keys = <V>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
        };
        ak_E: ak_E {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp E>;

            akE_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(E)>; strict-modifiers; };
            akE_t_u { trigger-keys = <A>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp U>; };
        };
        ak_F: ak_F {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp F>;

            akF_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(F)>; strict-modifiers; };
            akF_t_v { trigger-keys = <D>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp V>; };
            akF_t_s { trigger-keys = <P>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp S>; };
        };
        ak_G: ak_G {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp G>;

            akG_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(G)>; strict-modifiers; };
            akG_t_pg { trigger-keys = <J>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp P &kp G>; };
            akG_t_l  { trigger-keys = <K>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
            akG_b_gl { trigger-keys = <M>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp L &kp G>; };
            akG_b_lml { trigger-keys = <W>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp L &kp M &kp L>; };
        };
        ak_H: ak_H {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp H>;

            akH_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(H)>; strict-modifiers; };
            akH_t_a { trigger-keys = <U>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp A>; };
            akH_t_e { trigger-keys = <O>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp E>; };
            akH_t_l { trigger-keys = <N>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
            akH_t_n { trigger-keys = <L M>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp N>; };
            akH_t_o { trigger-keys = <E>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp O>; };
            akH_t_u { trigger-keys = <A>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp U>; };
            akH_t_sqt { trigger-keys = <Y>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp SQT>; };
        };
        ak_I: ak_I {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp I>;

            akI_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(I)>; strict-modifiers; };
        };
        ak_J: ak_J {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp J>;

            akJ_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(J)>; strict-modifiers; };
            akJ_t_gen { trigger-keys = <A E I O U Y B H>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp SQT &kp S>; };
            akJ_t_th { trigger-keys = <G>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp T &kp H>; };
            akJ_t_l { trigger-keys = <M W>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
        };
        ak_K: ak_K {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp K>;

            akK_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(K)>; strict-modifiers; };
            akK_b_lk { trigger-keys = <D G>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp L &kp K>; };
            akK_b_ck { trigger-keys = <T>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp C &kp K>; };
        };
        ak_L: ak_L {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp L>;

            akL_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(L)>; strict-modifiers; };
            akW_t_p { trigger-keys = <P>; max-prior-idle-ms = <my_ak_term>; bindings = <&sl_L>; };
        };
        ak_M: ak_M {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp M>;

            akM_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(M)>; strict-modifiers; };
            akM_t_l { trigger-keys = <G P X>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
            akM_b_l { trigger-keys = <W>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp L &sl_M>; };
        };
        ak_N: ak_N {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp N>;

            akN_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(N)>; strict-modifiers; };
            akN_t_ion { trigger-keys = <T>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp I &kp O &kp N>; };
        };
        ak_O: ak_O {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp O>;

            akO_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(O)>; strict-modifiers; };
        };
        ak_P: ak_P {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp P>;

            akP_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(P)>; strict-modifiers; };
            akP_t_g { trigger-keys = <D>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp G>; };
            akP_b_sp { trigger-keys = <F>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp S &kp P>; };
        };
        ak_Q: ak_Q {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp Q>;

            akQ_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(Q)>; strict-modifiers; };
        };
        ak_R: ak_R {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp R>;

            akR_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(R)>; strict-modifiers; };
            akR_t_l { trigger-keys = <L>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
        };
        ak_S: ak_S {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp S>;

            akS_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(S)>; strict-modifiers; };
        };
        ak_T: ak_T {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp T>;

            akT_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(T)>; strict-modifiers; };
            akT_n  { trigger-keys = <K>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp N>; };
        };
        ak_U: ak_U {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp U>;

            akU_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(U)>; strict-modifiers; };
        };
        ak_V: ak_V {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp V>;

            akV_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(V)>; strict-modifiers; };
            akV_b_lv { trigger-keys = <T>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp L &kp V>; };
        };
        ak_W: ak_W {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp W>;

            akW_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(W)>; strict-modifiers; };
            akW_t_p { trigger-keys = <M X>; max-prior-idle-ms = <my_ak_term>; bindings = <&sl_P>; };
        };
        ak_X: ak_X {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp X>;

            akX_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(X)>; strict-modifiers; };
            akX_t_j { trigger-keys = <D>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp J>; };
            akX_t_t { trigger-keys = <G>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp T>; };
            akX_t_l { trigger-keys = <M>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp L>; };
            akX_t_s { trigger-keys = <W>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp S>; };
        };
        ak_Y: ak_Y {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp Y>;

            akY_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(Y)>; strict-modifiers; };
        };
        ak_Z: ak_Z {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp Z>;

            akZ_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(Z)>; strict-modifiers; };
        };

        hml: home_row_mod_left {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "balanced";
            require-prior-idle-ms = <150>;
            tapping-term-ms = <280>;
            quick-tap-ms = <175>;
            bindings = <&kp>, <&kp>;

            hold-trigger-key-positions = <5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 33 34 35>;
            hold-trigger-on-release;
        };

        hmr: home_row_mod_right {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "balanced";
            require-prior-idle-ms = <150>;
            tapping-term-ms = <280>;
            quick-tap-ms = <175>;
            bindings = <&kp>, <&kp>;

            hold-trigger-key-positions = <0 1 2 3 4 10 11 12 13 14 20 21 22 23 24 30 31 32>;
            hold-trigger-on-release;
        };


        mt_S: mt_S {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "hold-preferred";
            tapping-term-ms = <200>;
            bindings = <&kp>, <&ak_S>;
            hold-trigger-key-positions = <5 6 7 8 9 15 16 17 18 19 25 26 27 28 29 33 34 35>; // right hand allowed
        };
        mt_C: mt_C {  
            hml;
            bindings = <&kp>, <&ak_C>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // left hand allowed
        };
        mt_N: mt_N {
            hml;
            bindings = <&kp>, <&ak_N>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // left hand allowed
        };
        mt_T: mt_T {
            hml;
            bindings = <&kp>, <&ak_T>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // left hand allowed
        };
        mt_A: mt_A {
            hmr;
            bindings = <&kp>, <&ak_A>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // right hand allowed
       };
        mt_E: mt_E {
            hmr;
            bindings = <&kp>, <&ak_E>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // right hand allowed
        };
        mt_I: mt_I {
            hmr;
            bindings = <&kp>, <&ak_I>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // right hand allowed
        };
        mt_H: mt_H {
            hmr;
            bindings = <&kp>, <&ak_H>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // right hand allowed
        };
    };

    combos {
        compatible = "zmk,combos";

        /*
 * vf-combo.dtsi
 *
 * SPDX-License-Identifier: MIT
 *
 */


/*
 * These are all alpha combos that need to be in specific places
 * depending on the underlying alpha. Q and Z are typically
 * off the primary alpha layer, so they are required.
 * Most of the rest are very optional, and are thus conditionally
 * compiled.
 *
 */


/*                       UNIVERSAL KEY POSITION NAMES
 *          alphas & combos limited to 3x5+2 common core
 *
 * FRA   FR1 FR2 FR3 FR4 FR5                      FR6 FR7 FR8 FR9 FR0   FRB
 * NRA   NR1 NR2 NR3 NR4 NR5                      NR6 NR7 NR8 NR9 NR0   NRB
 *     ╭─────────────────────╮                  ╭─────────────────────╮
 * LT5 │ LT4 LT3 LT2 LT1 LT0 │ LTA          RTA │ RT0 RT1 RT2 RT3 RT4 │ RT5
 * LM5 │ LM4 LM3 LM2 LM1 LM0 │ LMA          RMA │ RM0 RM1 RM2 RM3 RM4 │ RM5
 * LB5 │ LB4 LB3 LB2 LB1 LB0 │ LBA LBB  RBB RBA │ RB0 RB1 RB2 RB3 RB4 │ RB5
 *     ╰────────────╮LH2 LH1 | LH0 LHA  RHA RH0 | RH1 RH2╭────────────╯
 *      LH5 LH4 LH3 ╰────────╯                  ╰────────╯ RH3 RH4 LH5
*/

//
// type a glyph (tiny board accommodation)
//

COMBO_LAYER(t_Q,     &lk_qu Q U,    LT3 LT1, l_hd)       // type Qu, linger deletes u
COMBO_LAYER(t_Z,     &ak_Z,         LM3 LM1, l_hd)       // Z is typically off map

#ifdef H_DIGRAPH_COMBOS
//
// H Digraphs macros/behaviors (defined earlier) to process
//
COMBO_LAYER(sch,    &t_Sch,         LM4 LM3 LM2, l_hd)   // Sch
COMBO_LAYER(tch,    &t_Tch,         LM4 LM3 LM1, l_hd)   // Tch
COMBO_LAYER(th,     &t_Th,          LM2 LM1, l_hd)       // Th
COMBO_LAYER(ch,     &t_Ch,          LM3 LM2, l_hd l_jp)  // Ch
COMBO_LAYER(wh,     &t_Wh,          LT3 LT2, l_hd)       // Wh
COMBO_LAYER(sh,     &lk_sh H S,     LM4 LM3, l_hd l_jp)  // Sh/sion
COMBO_LAYER(gh,     &lk_gh H G,     LT2 LT1, l_hd)       // Gh/ght
COMBO_LAYER(ph,     &t_Ph,          LB3 LB1, l_hd)       // Ph
#endif

#ifdef EN_PRONOUN_COMBOS

/* Pronoun combos macros (define paired macros in moutis_config.dtsi) */

COMBO_LAYER(pnI,        &t_PnI,     RM3 RM4, l_hd)  // "I "
COMBO_LAYER(pnIm,       &t_PnIm,    RM3 LT2, l_hd)  // "I'm "
COMBO_LAYER(pnIll,      &t_PnIll,   RM3 LB2, l_hd)  // "I'll "
COMBO_LAYER(pnId,       &t_PnId,    RM3 LB1, l_hd)  // "I'd "
COMBO_LAYER(pnIve,      &t_PnIve,   RM3 LB0, l_hd)  // "I've "

COMBO_LAYER(pnYou,      &t_Pnyou,   RB1 RB2  RB3, l_hd) // “You”
COMBO_LAYER(pnYoure,    &t_PnYoure, RB3 LB4, l_hd)  // "You're "
COMBO_LAYER(pnYour,     &t_PnYour,  RB3 LB3, l_hd)  // "Your "
COMBO_LAYER(pnYoull,    &t_PnYoull, RB3 LB2, l_hd)  // "You'll "
COMBO_LAYER(pnYoud,     &t_PnYoud,  RB3 LB1, l_hd)  // "You'd "
COMBO_LAYER(pnYouve,    &t_PnYouve, RB3 LB0, l_hd)  // "You've "

COMBO_LAYER(pnWere,     &t_PnWere,  LT4 RT4, l_hd)  // "We're "
COMBO_LAYER(pnWell,     &t_PnWell,  LT4 LT2, l_hd)  // "We'll "
COMBO_LAYER(pnWed,      &t_PnWed,   LT4 LT1, l_hd)  // "We'd "
COMBO_LAYER(pnWeve,     &t_PnWeve,  LT4 LT0, l_hd)  // "We've "

COMBO_LAYER(pnWhere,    &t_PnWhere, LT4 LH1, l_hd)  // "Where "

#endif // EN_PRONOUN_COMBOS

#ifdef JP_MODE_ENABLE      // JP layer combos, etc.
COMBO_LAYER(jp_t_Q,     &kp Q,      LT3 LT1, l_jp)  // type Q
COMBO_LAYER(jp_t_Z,     &kp Z,      LM3 LM1, l_jp)  // type Z

COMBO_LAYER(jp_t_wo,    &t_wo,      LT3 LT2, l_jp)  // を
COMBO_LAYER(jp_t_shi,   &t_watashi, RM3 RM4, l_jp)  // わたし

#ifdef JP_YOUON_COMBOS     // Major Japanese contracted sounds as combos

COMBO_LAYER(jp_t_kya,   &t_kya,     LM0 RM1, l_jp)  // kya
COMBO_LAYER(jp_t_kyu,   &t_kyu,     LM0 RB1, l_jp)  // kyu
COMBO_LAYER(jp_t_kyo,   &t_kyo,     LM0 RB2, l_jp)  // kyo
COMBO_LAYER(jp_t_gya,   &t_gya,     LT1 RM1, l_jp)  // gya
COMBO_LAYER(jp_t_gyu,   &t_gyu,     LT1 RB1, l_jp)  // gyu
COMBO_LAYER(jp_t_gyo,   &t_gyo,     LT1 RB2, l_jp)  // gyo

COMBO_LAYER(jp_t_sya,   &t_sya,     LM4 RM1, l_jp)  // sya
COMBO_LAYER(jp_t_syu,   &t_syu,     LM4 RB1, l_jp)  // syu
COMBO_LAYER(jp_t_sye,   &t_sye,     LM4 RM2, l_jp)  // sye
COMBO_LAYER(jp_t_syo,   &t_syo,     LM4 RB2, l_jp)  // syo
COMBO_LAYER(jp_t_jya,   &t_jya,     LM3 RM1, l_jp)  // jya (C=Z in Japanese mode)
COMBO_LAYER(jp_t_jyu,   &t_jyu,     LM3 RB1, l_jp)  // jyu
COMBO_LAYER(jp_t_jye,   &t_jye,     LM3 RM2, l_jp)  // jye
COMBO_LAYER(jp_t_jyo,   &t_jyo,     LM3 RB2, l_jp)  // jyo

COMBO_LAYER(jp_t_tya,   &t_tya,     LM1 RM1, l_jp)  // tya
COMBO_LAYER(jp_t_tyi,   &t_tyi,     LM1 RM3, l_jp)  // tyi
COMBO_LAYER(jp_t_tyu,   &t_tyu,     LM1 RB1, l_jp)  // tyu
COMBO_LAYER(jp_t_tyo,   &t_tyo,     LM1 RB2, l_jp)  // tyo
COMBO_LAYER(jp_t_dya,   &t_dya,     LB1 RM1, l_jp)  // dya
COMBO_LAYER(jp_t_dyi,   &t_dyi,     LB1 RM3, l_jp)  // dyi
COMBO_LAYER(jp_t_dyu,   &t_dyu,     LB1 RB1, l_jp)  // dyu
COMBO_LAYER(jp_t_dyo,   &t_dyo,     LB1 RB2, l_jp)  // dyo

COMBO_LAYER(jp_t_nya,   &t_nya,     LM2 RM1, l_jp)  // nya
COMBO_LAYER(jp_t_nyu,   &t_nyu,     LM2 RB1, l_jp)  // nyu
COMBO_LAYER(jp_t_nyo,   &t_nyo,     LM2 RB2, l_jp)  // nyo

COMBO_LAYER(jp_t_hya,   &t_hya,     RM4 RM1, l_jp)  // hya
COMBO_LAYER(jp_t_hyu,   &t_hyu,     RM4 RB1, l_jp)  // hyu
COMBO_LAYER(jp_t_hyo,   &t_hyo,     RM4 RB2, l_jp)  // hyo
COMBO_LAYER(jp_t_bya,   &t_bya,     RB4 RM1, l_jp)  // bya
COMBO_LAYER(jp_t_byu,   &t_byu,     RB4 RB1, l_jp)  // byu
COMBO_LAYER(jp_t_byo,   &t_byo,     RB4 RB2, l_jp)  // byo
COMBO_LAYER(jp_t_pya,   &t_pya,     LB3 RM1, l_jp)  // pya
COMBO_LAYER(jp_t_pyu,   &t_pyu,     LB3 RB1, l_jp)  // pyu
COMBO_LAYER(jp_t_pyo,   &t_pyo,     LB3 RB2, l_jp)  // pyo

COMBO_LAYER(jp_t_mya,   &t_mya,     LT2 RM1, l_jp)  // mya
COMBO_LAYER(jp_t_myu,   &t_myu,     LT2 RB1, l_jp)  // myu
COMBO_LAYER(jp_t_myo,   &t_myo,     LT2 RB2, l_jp)  // myo

COMBO_LAYER(jp_t_rya,   &t_rya,     LH1 RM1, l_jp)  // rya
COMBO_LAYER(jp_t_ryu,   &t_ryu,     LH1 RB1, l_jp)  // ryu
COMBO_LAYER(jp_t_ryo,   &t_ryo,     LH1 RB2, l_jp)  // ryo

#endif //  JP_YOUON_COMBOS     // Major Japanese contracted sounds as combos

#endif // JP_MODE_ENABLE      // JP layer combos, etc.


        kha {
            bindings = <&kp RU_CYRILLIC_HA>;
            key-positions = <6 7>;
            layers = <1>;
        };

        hrdsgn {
            bindings = <&kp RU_CYRILLIC_HARD_SIGN>;
            key-positions = <7 8>;
            layers = <1>;
        };

        cmben {
            bindings = <&layer_en>;
            key-positions = <2 3>;
            layers = <1>;
        };

        cmbru {
            bindings = <&layer_ru>;
            key-positions = <2 3>;
            layers = <0>;
        };
    };

    macros {
        to_ru: to_ru {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp LS(LC(N2))>;
            label = "TO_RU";
            wait-ms = <0>;
            tap-ms = <30>;
        };

        to_en: to_en {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&kp LS(LC(N1))>;
            label = "TO_EN";
            wait-ms = <0>;
            tap-ms = <30>;
        };

        layer_en: layer_en {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&to 0 &to_en>;
            label = "LAYER_EN";
            wait-ms = <0>;
            tap-ms = <30>;
        };

        layer_ru: layer_ru {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings = <&to 1 &to_ru>;
            label = "LAYER_RU";
            tap-ms = <30>;
            wait-ms = <0>;
        };

        en: en {
            compatible = "zmk,behavior-macro-one-param";
            #binding-cells = <1>;
            bindings =
                <&to_en>,
                <&macro_press>,
                <&macro_param_1to1 &kp MACRO_PLACEHOLDER>,
                <&macro_pause_for_release>,
                <&macro_release>,
                <&macro_param_1to1 &kp MACRO_PLACEHOLDER>,
                <&macro_tap>,
                <&to_ru>;

            label = "EN";
            wait-ms = <0>;
            tap-ms = <30>;
        };
    };

    keymap {
        compatible = "zmk,keymap";

        /*      Base (alpha) Layer Hands Down Vibranium-vf
                            34 keys (core)
         ╭─────────────────────╮ ╭──────────────────────╮
         │  X   W   M   G   J  │ │  #$  .:  /*  "<  '>  │
         │  S   C   N   T   K  | |  ,;   A   E   I   H  │
         │  F   P   L   D   V  │ │  -+   U   O   Y   B  │
         ╰──────────╮  BSP  R  │ │  SPC RET  ╭──────────╯
                    ╰──────────╯ ╰───────────╯        

        #define HD_Layer_label "HD-Vf"
        #define HD_LT &ak_X           &ak_W           &ak_M           &ak_G           &ak_J
        #define HD_LM &mt_S LCTRL S   &mt_C LALT C    &mt_N LGUI N    &mt_T LSHFT T   &ak_K
        #define HD_LB &ak_F           &ak_P           &ak_L           &ak_D           &ak_V
        #define HD_LH                                                 &lt_BSPC l_fun BSPC   &lt_R l_nav R

        #define HD_RT &HashDllr       &DotColn        &SlshStar       &DqtLT          &SqtGT
        #define HD_RM &CommaMagic     &mt_A RSHFT A   &mt_E RGUI E    &mt_I RALT I    &mt_H RCTRL H
        #define HD_RB &MinusPlus      &ak_U           &ak_O           &ak_Y           &ak_B
        #define HD_RH &lt l_sym SPACE &lt l_nav RETURN
        */


        en {
            bindings = <
  &ak_X        &ak_W        &ak_M         &ak_G          &ak_J                          &HashDllr    &DotColn        &SlshStar      &DqtLT        &SqtGT
  &mt_S LGUI 0 &mt_C LALT C &mt_N LSHFT N &mt_T LCTRL T  &ak_K                          &CommaMagic  &mt_A RCTRL A   &mt_E RSHFT E  &mt_I LALT I  &mt_H RGUI H
  &ak_F        &ak_P        &ak_L         &ak_D          &ak_V                          &MinusPlus   &ak_U           &ak_O          &ak_Y         &ak_B
                                          &kp BACKSPACE  &kp R  &kp SPACE    &kp TAB  &kp SPACE  &kp RETURN
            >;

            display-name = "Base";
        };

        ru {
            bindings = <
  &kp RU_CYRILLIC_SHORT_I   &kp RU_CYRILLIC_TSE         &kp RU_CYRILLIC_U          &kp RU_CYRILLIC_KA        &kp RU_CYRILLIC_IE                          &kp RU_CYRILLIC_EN  &kp RU_CYRILLIC_GHE        &kp RU_CYRILLIC_SHA        &kp RU_CYRILLIC_SHCHA     &kp RU_CYRILLIC_ZE
  &hml LGUI RU_CYRILLIC_EF  &hml LALT RU_CYRILLIC_YERU  &hml LSHFT RU_CYRILLIC_VE  &hml LCTRL RU_CYRILLIC_A  &kp RU_CYRILLIC_PE                          &kp RU_CYRILLIC_ER  &hmr RCTRL RU_CYRILLIC_O   &hmr RSHFT RU_CYRILLIC_EL  &hmr LALT RU_CYRILLIC_DE  &hmr RGUI RU_CYRILLIC_ZHE
  &kp RU_CYRILLIC_YA        &kp RU_CYRILLIC_CHE         &kp RU_CYRILLIC_ES         &kp RU_CYRILLIC_EM        &kp RU_CYRILLIC_I                           &kp RU_CYRILLIC_TE  &kp RU_CYRILLIC_SOFT_SIGN  &kp RU_CYRILLIC_BE         &kp RU_CYRILLIC_YU        &kp RU_CYRILLIC_E
                                                                                   &kp BACKSPACE             &mo 4               &kp SPACE    &kp ENTER  &mo 3               &kp TAB
            >;

            display-name = "Ru";
        };

        sym_en {
            bindings = <
  &kp TILDE       &kp LT          &kp EQUAL         &kp GT           &kp GRAVE                    &kp CARET  &kp LBKT         &kp UNDER        &kp RBKT        &kp DLLR
  &hml LGUI BSLH  &hml LALT LPAR  &hml LSHFT MINUS  &hml LCTRL RPAR  &kp PLUS                     &kp PRCNT  &hmr RCTRL LBRC  &hmr RSHFT SEMI  &hmr LALT RBRC  &hmr RGUI EXCL
  &kp HASH        &kp STAR        &kp COLON         &kp FSLH         &kp AMPS                     &kp AT     &kp PIPE         &kp COMMA        &kp DOT         &kp QMARK
                                                    &trans           &mo 5      &trans    &trans  &none      &trans
            >;

            display-name = "Symbols";
        };

        sym_ru {
            bindings = <
  &en TILDE               &en LT          &kp EQUAL         &en GT           &en GRAVE                    &en CARET  &en LBKT  &kp UNDER           &en RBKT    &en DLLR
  &hml LGUI RU_BACKSLASH  &hml LALT LPAR  &hml LSHFT MINUS  &hml LCTRL RPAR  &kp PLUS                     &kp PRCNT  &en LBRC  &hmr RSHFT RU_SEMI  &en RBRC    &hmr RGUI EXCL
  &en HASH                &kp STAR        &kp RU_COLON      &kp RU_FSLH      &en AMPS                     &en AT     &en PIPE  &kp RU_COMMA        &kp RU_DOT  &kp RU_QMARK
                                                            &trans           &mo 5      &trans    &trans  &none      &trans
            >;

            display-name = "Symbols";
        };

        nav {
            bindings = <
  &kp N1         &kp N2    &kp N3     &kp N4     &kp N5                        &kp N6           &kp N7           &kp N8           &kp N9        &kp N0
  &hml LGUI ESC  &kp LALT  &kp LSHFT  &kp LCTRL  &kp ENTER                     &kp PRINTSCREEN  &hmr RCTRL LEFT  &hmr RSHFT DOWN  &hmr LALT UP  &hmr RGUI RIGHT
  &layer_en      &kp HOME  &kp INS    &kp END    &kp DELETE                    &kp CAPS         &none            &kp PG_DN        &kp PG_UP     &layer_ru
                                      &trans     &none       &trans    &trans  &mo 5            &trans
            >;

            display-name = "Navigation";
        };

        adj {
            bindings = <
  &bootloader  &kp F1        &kp F2         &kp F3         &kp F4                     &bt BT_SEL 0  &bt BT_SEL 1         &bt BT_SEL 2       &bt BT_SEL 3        &bt BT_CLR
  &kp LGUI     &hml LALT F5  &hml LSHFT F6  &hml LCTRL F7  &kp F8                     &out OUT_BLE  &hmr RCTRL C_VOL_DN  &hmr RSHFT C_MUTE  &hmr LALT C_VOL_UP  &kp RGUI
  &none        &kp F9        &kp F10        &kp F11        &kp F12                    &out OUT_USB  &kp C_PREV           &kp C_PP           &kp C_NEXT          &studio_unlock
                                            &trans         &trans   &trans    &trans  &trans        &trans
            >;

            display-name = "Adjust";
        };
    };
};
